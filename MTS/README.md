# Mobile Target Search

## Statement

https://ocw.cs.pub.ro/courses/pp/21/teme/target-search

## About

The aim of this project is implementing a game - **Mobile Target Search** - by using lazy search in the state space. Thus, the **A*** algorithm will be used for optimising the search.

The game is set on a 2D terrain, having the following characters:

- **hunter**, represented by *!*, which has to catch the targets;
- **targets**, represented by *\**;
- **obstacles**, represented by *@*;
- **gateways**, represented by *#*, which can be used by the hunter and targets for teleporting.

The allowed *moves* are by horizontal and vertical with a position.

Each **target** has:

- a *position*;
- a *behavior*, based on which it chooses the next move depending on its current position.

### **State Space**

The hunter is *planning* its move depending on the current position of one of the targets, resulting in a **search** in the *state space* of the game. Given that the hunter does not know the targets' behaviors, it is considered that the paths imagined by the hunter only reflect its moves, not the targets', **as if** they would not be influenced by the hunter's moves.

The *state space* can be seen as a **graph**, in which:

- the **vertices** are the possible configurations of the game and
- the **edges** are the hunter's moves, by which it shifts in between the states.

### **A\* algorithm**

In this project, the usage of the **A\*** algorithm is as an **informed search algorithm** in the *state space* of the game, which help the hunter pick the *best* path for catching a target. That is why the following are needed:

- a **tree** of paths having a *start* node and **extending** those paths by a criterion;
- a **heuristic**, for *prioritising* the targets.
    - at first, it is the euclidean distance between two points
    - the latter is improved by taking the **gateways** into account when calculating the distance

This way, a **priority** queue is being used, both for *prioritising* the expansion of the more "promising" nodes, and also for the possibility of reintroducing the nodes in the queue (also known as *frontier*).

## Implementation

The game **components** and **display**, as well as the characters' **definitions**, are implemented in *Basics.hs*, which also contains the possible **moves** that can be made.

*ProblemState.hs* contains the class which generically interfaces the functions for generating the state space.

In *Search.hs* the **Node s a** data type is defined, needed for representing the state space. This file also contains the **A\* algorithm** implementation, being divided in several functions for keeping track of the nodes added and erased from the priority queue.

## Testing

Testing can be done:

- automatically, by running all the given tests **(1)**
- manually, by simulating the gameplay in the command line **(2)**

**(1)** can be done using the following commands:

> stack exec ghci --package PSQueue TestMTS.hs\
> *TestMTS.hs> checkAll

For **(2)**:

> stack exec ghci --package PSQueue Interactive.hs\
> *Interactive.hs> hunt True $ loadGame "terrains/terrain-1.txt" [goNorth, goSouth] [(0, 1)]
- starts the game for terrain-1
- the next move of the A* algorithm is generated by pressing `enter`
